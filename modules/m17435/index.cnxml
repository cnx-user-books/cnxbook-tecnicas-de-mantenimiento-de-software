<document xmlns="http://cnx.rice.edu/cnxml" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Técnicas de la Ingeniería Inversa de Datos</title>
  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>b4646ed7-41e3-4fd4-93dc-00012e39c8cd</md:uuid>
</metadata>
  <content>
    <para id="id17953409">La ingeniería inversa de datos se aplica sobre algún código de bases de datos (aplicación, código SQL, etc.) para obtener los modelos relacionales o sobre el modelo relacional para obtener el diagrama entidad-relación. Hay que tener en cuenta que la ingeniería inversa se puede dar entre distintos productos del ciclo de vida de una aplicación.</para>
    <para id="id18238580">Existen muchas técnicas para hacer ingeniería inversa de base de datos, algunos de los cuales se pueden ver resumidos en la siguiente tabla:</para>
    <list list-type="bulleted" id="id13918542">
      <item>Baltín et al (1992):<list list-type="bulleted" id="id20075187"><item>Suposiciones: 3FN. Consistencia en el nombrado de los atributos. Sin homónimos. Clave principal y clave candidata.</item><item>Entradas: Dependencias. Esquemas de relación.</item><item>Salidas: Entidades. Relaciones binarias. Categorías. Generalizaciones.</item><item>Basado en el método de Navathe de Awongs.</item></list></item>
      <item>Chiang et al (1994,1996):<list list-type="bulleted" id="id17364398"><item>Suposiciones: 3FN. Consistencia en el nombrado de los atributos. Sin errores en los atributos claves.</item><item>Entradas: Esquema de relación. Instancia de datos. Dependencias.</item><item>Salidas: Entidades. Relaciones binarias. Generalizaciones. Agregaciones.</item><item>Características: Requiere el conocimiento acerca del nombre de los atributos. Propone un marco de trabajo para la evaluación de los métodos de ingeniería inversa. Identifica claramente los casos en los que las entradas de los humanos son necesarias.</item></list></item>
      <item>Davids &amp; Arora (1987):<list list-type="bulleted" id="id9632740"><item>Suposiciones: 3FN. Sin homónimos ni sinónimos.</item><item>Entradas: Esquemas de relación. Restricciones de claves ajenas.</item><item>Salidas: Conjunto de entidades. Relaciones binarias. Relaciones n-aria. </item><item>Características: Apunta a una transformación reversible desde el esquema relacional al esquema conceptual.</item></list></item>
      <item>Johannessin (1994):<list list-type="bulleted" id="id10057933"><item>Suposiciones: 3FN. Consultas de dominio independientes.</item><item>Entradas: Dependencias funcionales y de inclusión. Esquemas de relación.</item><item>Salidas: Generalizaciones. Entidades. Relaciones binarias.</item><item>Características: Basado en los conceptos establecidos de las teoría de bases de datos relacionales. Proceso de mapeo simple y automático.</item></list></item>
      <item>Markowitz &amp; Makowsky (1990):<list list-type="bulleted" id="id10948514"><item>Suposiciones: FN Boycce-Codd.</item><item>Entradas: Esquemas de relación. Dependencias de claves. Dependencias de integridad referencial.</item><item>Salidas: Entidades. Relaciones binarias. Generalizaciones y agregaciones.</item><item>Características: Requiere todas las dependencias de clave.</item></list></item>
      <item>Navathe &amp; Among (1987):<list list-type="bulleted" id="id13790111"><item>Suposiciones: 3FN y algunos 2FN. Consistencia en el nombrado de atributos. Sin ambigüedades de clave ajena. Claves candidatas específicas.</item><item>Entradas: Esquemas de relación.</item><item>Salidas: Entidades. Relaciones binarias. Categorías. Cardinalidades.</item><item>Características. Es vulnerable a la ambigüedad en el reconocimiento de claves ajenas.</item></list></item>
      <item>Petit et al (1996):<list list-type="bulleted" id="id14663884"><item>Suposiciones: 1FN. Atributos únicos.</item><item>Entradas: Esquemas de relación. Instancia de datos y código.</item><item>Salidas: Entidades. Relaciones. Generalizaciones.</item><item>Características: Analiza las consultas en los programas de aplicación. No pone restricciones en el nombre de los atributos.</item></list></item>
      <item>Permerlani &amp; Blaha (1993,1994):<list list-type="bulleted" id="id19437362"><item>Suposiciones: Sin F3N. Comprensión semántica de aplicación.</item><item>Entradas: Esquemas de relación. Observaciones de patrones de datos.</item><item>Salidas: Clases. Asociaciones. Generalizaciones. Multiplicidad. Agregación.</item><item>Características: Requiere un alto nivel de entrada de los humanos. Enfatiza en el análisis de las claves.</item></list></item>
      <item>Sotou (1997,1998):<list list-type="bulleted" id="id10088256"><item>Suposiciones: Sin nombres únicos de atributos. Dependencias desconocidas.</item><item>Entradas: Esquema de datos. Instancia de datos. Diccionario de datos.</item><item>Salidas: Cardinalidad de las restricciones de relaciones n-arias.</item><item>Características: Proceso automatizado completamente para SQL.</item></list></item>
    </list>
    <para id="id21174894">Entre las distintas técnicas de Ingeniería Inversa de datos, se propone el método de Hainaut et al () para explicarla. </para>
    <para id="id10354911">El método pasa por dos fases. En la 1ª fase se realiza la extracción de estructuras y en la 2ª la conceptualización de las mismas:</para>
    <figure id="id5465539">
      <media id="idm6358096" alt=""><image src="../../media/graphics1-4fa4.png" mime-type="image/png" height="352" width="573"/></media>
    </figure>
    <list list-type="enumerated" id="id20077169">
      <item>FASE I: Extracción de estructuras<list list-type="bulleted" id="id8485282"><item>Considerar cada fichero una posible tabla.</item><item>Considerar cada campo del fichero como un posible campo de la tabla.</item><item>Identificar las claves primarias.</item><item>Identificar claves ajenas.</item><item>“Filtrar” las tablas (por ejemplo, despreciar aquellos ficheros sin clave principal).</item><item>Detección de campos obligatorios.</item><item>Detección de asociaciones entre tablas</item></list></item>
      <item>FASE II: Conceptuación de las estructuras<list list-type="bulleted" id="id15399900"><item>Sustitución de constructores propios del sistema real por constructores independientes (ej: una tabla que es un elemento físico es sustituida por el concepto de entidad que es un elemento lógico).</item><item>Detección y eliminación de los constructores no semánticos del esquema lógico, paso inverso a la optimización del esquema (ej: deshacer la normalización de un SGBD relacional).</item><item>Normalización conceptual para obtener estructuras de alto nivel.</item></list></item>
    </list>
  </content>
</document>